//
//  BatchedSprite3D.cpp
//  CocosWolf3D
//
//  Created by Michael Edwards on 2/9/17.
//
//

#include "BatchedSprite3D.hpp"

using namespace mikedotcpp;

BatchedSprite3D* BatchedSprite3D::create()
{
    auto sprite = new (std::nothrow) BatchedSprite3D();
    if (sprite && sprite->init())
    {
        sprite->autorelease();
        return sprite;
    }
    CC_SAFE_DELETE(sprite);
    return nullptr;
}

BatchedSprite3D* BatchedSprite3D::create( const std::string &modelPath )
{
    CCASSERT(modelPath.length() >= 4, "invalid filename for BatchedSprite3D");
    
    auto sprite = new (std::nothrow) BatchedSprite3D();
    if ( sprite && sprite->initWithFile( modelPath ) )
    {
        sprite->_contentSize = sprite->getBoundingBox().size;
        sprite->autorelease();
        return sprite;
    }
    CC_SAFE_DELETE( sprite );
    return nullptr;
}

/**
 * NOTE: The content of this function is basically the same as the base-class version except for adding two new
 *       variables: _instanceCount and _positionPalette.
 */
void BatchedSprite3D::draw( cocos2d::Renderer *renderer, const cocos2d::Mat4 &transform, uint32_t flags)
{
#if CC_USE_CULLING
    // camera clipping
    if( _children.size() == 0 && cocos2d::Camera::getVisitingCamera() && !cocos2d::Camera::getVisitingCamera()->isVisibleInFrustum( &getAABB() ) && _instanceCount > 1 )
    {
        return;
    }
#endif
    
    if( _skeleton )
    {
        _skeleton->updateBoneMatrix();
    }
    
    cocos2d::Color4F color( getDisplayedColor() );
    color.a = getDisplayedOpacity() / 255.0f;
    
    //check light and determine the shader used
    const auto& scene = cocos2d::Director::getInstance()->getRunningScene();
    
    // Don't override GLProgramState if using manually set Material
    if( _usingAutogeneratedGLProgram && scene )
    {
        const auto lights = scene->getLights();
        bool usingLight = false;
        for( const auto light : lights )
        {
            usingLight = light->isEnabled() && ( (static_cast<unsigned int>( light->getLightFlag() ) & _lightMask ) > 0);
            if( usingLight )
            {
                break;
            }
        }
        if( usingLight != _shaderUsingLight )
        {
//            genMaterial(usingLight);
        }
    }
    
    for (auto mesh: _meshes)
    {
        static_cast< BatchedMesh* >( mesh )->draw( renderer,
                   _globalZOrder,
                   transform,
                   flags,
                   _lightMask,
                   cocos2d::Vec4(color.r, color.g, color.b, color.a),
                   _forceDepthWrite,
                   _instanceCount,
                   _positionPalette );
    }
}

void BatchedSprite3D::setInstanceCount( int count )
{
    _instanceCount = count;
}

int BatchedSprite3D::getInstanceCount()
{
    return _instanceCount;
}

void BatchedSprite3D::setPositionPalette( const std::vector< cocos2d::Vec3 >& positionArray )
{
    _positionPalette = positionArray;
}

cocos2d::Vec3* BatchedSprite3D::getPositionPalette()
{
    return &_positionPalette[0];
}
